\subsection{Ideas}
\subsubsection{Brandy King}
\begin{itemize}
  \item Smaller puzzles can be the parts of a larger cohesive piece
  \begin{itemize}
    \item The efficiency of a solution can dictate how well each piece works
    together
    \item Will reinforce revisiting puzzles that have already been solved to
    find more efficient solutions (leading to a better solution overall)
  \end{itemize}
  \item Variable and Data Structure Declaring
  \begin{itemize}
    \item Separate declaration field from the solution space
    \item Can add or remove variables/structures dynamically
  \end{itemize}
  \item Tutorial levels
  \begin{itemize}
    \item Explaining new instructions or data structures in a non-puzzle level
    \item Allow users to “free play” with their available commands and see how
    things work without the pressure of needing to use them to solve a puzzle
    \item A “to-do” list with checkboxes of key concepts they need for each
    command
    \begin{itemize}
      \item E.G. A Heap tutorial level “to-do” list would include:
      \begin{itemize}
        \item Declare a Heap
        \item Put five inputs in the Heap
        \item Remove five inputs from the Heap
      \end{itemize}
    \end{itemize}
    \item The “to-do” list must be completed before the user can progress to the
    next puzzle, where they will need to utilize the new element in the solution
  \end{itemize}
  \item Points-based scoring of solutions
  \begin{itemize}
    \item Quantify the solution provided with a ranking
    \item Informs users on the efficiency of their solution
  \end{itemize}
  \item Limiting certain commands
  \begin{itemize}
    \item Can’t select to use a data structure space that isn’t declared
    \item Certain commands will not be applicable to data structures
    \begin{itemize}
      \item I.e., data stored in a structure must be removed to be manipulated;
      cannot arbitrarily add or subtract values stored there
    \end{itemize}
    \item Commands with changeable parts will be limited to available locations
  \end{itemize}
  \item Indentation within if statements to emphasize scope
  \begin{itemize}
    \item Will more clearly define to users which commands are reached within
    conditionals; especially important when nested conditionals are introduced
  \end{itemize}
  \item Instruction “Jumbotron”
  \begin{itemize}
    \item An area above the puzzle space that broadcasts which command is being
    executed at that time
  \end{itemize}
\end{itemize}

\subsubsection{John Billingham}
\begin{itemize}
  \item Abstracting conditional jumps with more conventional IF/ELSE statements
  \item Counter that shows how many jumps have been used
  \item Jump iterations used as a finite resource to enforce efficiency
  \item Data Structures as Input/Output
  \begin{itemize}
    \item Arrays, etc
    \item Different data structures unlocked as the puzzle complexity increases
    \item An instruction set associated with each data structure, abstracting
    some of the earlier instructions a bit
  \end{itemize}
  \item Atomic move instructions
  \begin{itemize}
    \item Replacing need to pick up and place down data by combing those into
    one instruction
  \end{itemize}
  \item Add/Subtract specificities
  \item Color-based indexing system
  \item Return instruction
  \item Debugging levels
  \begin{itemize}
    \item Broken solution given initially
    \item Player must fix the broken solution
    \item Can be used in conjunction with tutorials to teach new concepts
  \end{itemize}
\end{itemize}

\subsubsection{Nicolas LaCognata}
\begin{itemize}
  \item Game in the vein of Human Resource Machine
  \begin{itemize}
    \item The player is presented with a limited, assembly-like instruction set
    that they must use to solve logic puzzles.
  \end{itemize}
  \item Data structures as tools
  \begin{itemize}
    \item Data structures are consistently ignored by games in our problem
    space. It would behoove us to take advantage of that gap, and come up with a
    fun and natural way of incorporating data structures into our puzzle format.
  \end{itemize}
  \item Card Game Mechanics
  \begin{itemize}
    \item “Card Playing”
    \begin{itemize}
      \item During our prototyping sessions, I came up with the idea of “Memory
      Cards”. These memory cards would allow the player to declare register
      locations and data structures before their program starts. Making
      mechanics of placing these memory cards similar to a game like Hearthstone
      would be a natural and compelling addition to our puzzle format. This
      “Memory Card” interface would be separate from the normal instruction
      writing interface, which helps reinforce the idea that they are separate
      parts of the puzzle.
    \end{itemize}
    \item “Card packs”
    \begin{itemize}
      \item Card games deliver goodies to players in little packages whose
      contents appear hidden. While discussing adapting card game mechanics, we
      realized that having that little unboxing moment when introducing new
      instructions to the player could be highly compelling.
      \item Other games in our problem space silently drop new instructions on
      the player as they progress. By making the new instructions appear as a
      reward, we can ensure that their addition gets the appropriate attention
      from the player.
    \end{itemize}
  \end{itemize}
\end{itemize}

\subsubsection{Sean Simonian}
\begin{itemize}
  \item Static commands and restricted dynamic commands
  \begin{itemize}
    \item Certain commands in the language should be static, such as “Read
    Input”
    \item Certain commands in the language should have components that can be
    selected from drop down menus, such as “Jump if (blank) (blank) (blank)”
    \begin{itemize}
      \item This command would have 3 sections to specify, so the user could
      specify this command to be “Jump if x > 0”
    \end{itemize}
  \end{itemize}
  \item Break more complex challenges into multiple steps that get checked along
  the way.
  \begin{itemize}
    \item User would have instructions to complete one step of the complete
    level challenge at a time, run their solution, and if they pass then they
    move onto the next step, etc., until they work up to the solution.
    \item This would help players grasp more complex concepts that would be
    harder to teach as a single challenge that they have to break down on their
    own.
    \item Example: Merge Sort algorithm
    \begin{itemize}
      \item Step 1: split an array in half
      \item Step 2: split an array in half recursively
      \item Step 3: compare 2 of the sub arrays and swap them if necessary
      \item Step 4: recursively compare and swap sub arrays to build back up to
      the full sorted array
    \end{itemize}
  \end{itemize}
  \item For testing the educational efficacy of the game, we could create a set
  of short questions to be done on paper that require computational thinking.
  Before a test subject plays our game, we have them work through a few of the
  questions. Then after the test subject plays our game, we have them work
  through a few more questions from the set. Compare the results to see if they
  indicate whether our game helps users with computational thinking and problem
  solving.
  \item For testing the educational efficacy of the game, conducting official
  tests through the UCF psych department would be very beneficial if we are able
  to do so.
  \begin{itemize}
    \item Students taking courses such as Intro to Psychology are required to
    spend a certain number of hours as a test subject as part of their course
    grade. They use SONA to view available tests and sign up for a time slot,
    and the experiments that involve playing video games tend to fill up very
    quickly.
    \item Since Intro to Psychology is a general education course, many subjects
    are freshman, and the majority are not studying computer science or similar
    majors. This could provide an abundant set of candidates that match our
    target audience.
    \item We have to figure out who to contact if we want to set this up for
    next semester.
    \item The UCF psychology department may only allow these official tests to
    be set up and run by psych majors and/or psych graduate students doing
    research. If this is the case, we could look for a grad student conducting
    educational research who would be interested in “sponsoring” these official
    tests.
  \end{itemize}
  \item Incorporate basic cyber security and cryptography concepts into additional
  challenges/puzzles.
  \begin{itemize}
    \item This was a goal early on, but the current design for the game
    mechanics would make this difficult to add to the game.
  \end{itemize}
  \item Initial ideas for computer science concepts to teach. As we narrowed
  down the specifications for our game, these ideas were thrown out as they will
  not fit in the game at all
  \begin{itemize}
    \item Artificial intelligence, neural networks, machine learning
    \item Blockchain technology and its applications
  \end{itemize}
\end{itemize}

\subsection{Papers}
During the prototyping phase of our project, we took the time to study research
centered around teaching computational thinking to beginners, with a special
interest in articles focused on game-based delivery of concepts. We wanted to
know how previous attempts at this approach succeeded and to ascertain which
parts were not successful, what caused them to fail, and how we can avoid the
same pitfalls in our own project. That way, we could make an informed decision
on the progression and clarity of instruction within our game.\\

One study was centered on a program designed to observe students’ abilities in
using Scratch to develop solutions for solving computationally based problems
[1]. Scratch is a drag-and-drop block-style programming interface designed for
children to help them learn how to code without requiring them to navigate the
intricacies of typing and compiling code. The program consisted of a discussion
of the topic coupled with a demonstration in Scratch and an emphasis on the
applicable computational thinking skills required, followed by students creating
their own Scratch based solutions [1]. The programs that the students developed
were evaluated for their ability to decompose the problem at hand and the skill
in efficient program development [1]. The study found that basic concepts like
sequence were easy for students to pick up on, but that as program requirements
became more sophisticated it was increasingly difficult for the participants to
compose and debug their programs [1]. Applying these findings to our own
sequence of instruction has informed us on the importance of properly conveying
the progression of topics. It is essential that we not only deliver clear
information about the mechanics of each element of our game, but also that we
properly articulate and demonstrate the more complex topics, such as nested if
statements or nested loops. The sequence of instructions and data structures
being introduced needs to support a logical progression from simple to more
complex topics, and it is necessary to ensure that players are familiar with
concepts before a new one is introduced. For example, we wouldn’t want to
introduce new instructions in succession, but rather require the player to solve
several puzzles with each element to build familiarity and comfort before a new
element is introduced.  Additionally, we recognize that proper conveyance of
debugging practices and insightful feedback on this practice is an integral
aspect of user success.\\

\todo{(if you have any research on computational thinking that you want to include,
but that isn’t focused specifically on using games to teach it, it should go
before the following paragraph. Make sure you update the references as required
- the list of references must be presented in the same order as each citation
first appears in the documentation, and if any citation moves down on the list,
it’s citation needs to be updated within the documentation)}\\

Other research we found concentrated more specifically on the effectiveness of
using games as a medium for teaching computational thinking to users.
Documentation concentrating on this topic was of special interest to us, as it
applies so directly to our goals for this project. There are already many
studies based around the idea of using game-based instruction for teaching, and
it has been firmly established that it is a successful medium for delivering
instructional content. The real issue we are facing is whether or not it can be
used effectively in regard to teaching computational thinking.\\

One such study we found aimed to teach computational thinking concepts using
“unplugged” games to teach the elements, and then following the unplugged
activities the students would apply what they had learned to correlated
“plugged-in” programming exercises [2]. The unplugged version included tangible
real world objects (e.g., a deck of cards) that students would physically
interact with in order to demonstrate understanding of a particular concept, and
the plugged-in version would present the participants with the same object
computationally and ask them to trace through a solution based on the concept
and rules they were already familiar with for that particular object. The
reasoning for this abstract approach is that the underlying computational
concepts can be learned in any medium, and that by removing the technological
applications the emphasis is specifically on the processing of information using
computational thinking instead of having the participants focus too much on the
technology they are using [2]. It was found that for most of the activities, a
majority of the students were able to accurately solve the tasks on the plugged-
in assessments with approximately 90 percent correctness [2]. However, the
activity that aimed to teach students about conditionals and nested conditionals
had very disappointing results, with students only solving 6 percent of the final
assessment for that lesson correctly [2]. There was also a questionnaire element
to this study designed to help the researchers measure the interest the students
had in pursuing an IT-related job, which the students filled out both before the
course and after it ended. Interestingly, the results actually indicated a
slight decline in students interested in choosing a related job after completing
the course, but contrastingly showed an increase in the desire to learn more
about computer science, and also indicated that students enjoyed the course and
felt they learned something valuable [2]. The shortcomings of this study with
respect to teaching conditionals can likely be attributed to not spending enough
time on the topic and the ending assessment being too complex [2]. This has
greatly informed us on how we want to introduce this topic within our own
project. First, we would like to introduce single conditionals in a tutorial
level and then have the user solve a non-trivial puzzle using the concept,
followed with another tutorial level showing them how to operate with nested
conditionals and a subsequent puzzle implementing that technique. Layering this
instruction instead of releasing it to them all at once should help users
understand the basics of conditionals before allowing them to get bogged down in
more complex applications. It should also be noted that the instructors for this
study were trained in teaching for only two hours a week over the course of
three months [2], whereas, cumulatively, the members of our team have years of
experience in teaching these concepts to novices. Still, the results of the
overall effectiveness of gamification of computational thinking concepts as a
solid method for instruction is very promising, and with the right approach we
know that our project can be successful.\\

\todo{(any research papers you need to report on that apply specifically to
game-based delivery of instruction should follow this paragraph; again, please
make sure you update the references accordingly -- both within this section and
in the references section, by order of appearance)}

\subsection{Initial Game Structure}
\newpage

\subsection{Prototypes}
\subsubsection{Brandy King}
\input{sections/prototypes/brandy_king}
\subsubsection{John Billingham}
\input{sections/prototypes/john_billingham}
\subsubsection{Nicolas LaCognata}
\input{sections/prototypes/nicolas_lacognata}
\subsubsection{Sean Simonian}
\input{sections/prototypes/sean_simonian}
