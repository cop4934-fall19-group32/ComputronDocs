During the prototyping phase of our project, we took the time to study research 
centered around teaching computational thinking to beginners, with a special interest 
in articles focused on game-based delivery of concepts. We wanted to know how 
previous attempts at this approach succeeded and to ascertain which parts were 
not successful, what caused them to fail, and how we can avoid the same pitfalls 
in our own project. That way, we could make an informed decision on the 
progression and clarity of instruction within our own game.\\

One study was centered on a program designed to observe students’ abilities in 
using Scratch to develop solutions for solving computationally based problems [1]. 
Scratch is a drag-and-drop block-style programming interface designed for children 
to help them learn how to code without requiring them to navigate the intricacies of 
typing and compiling code. The program consisted of a discussion of the topic 
coupled with a demonstration in Scratch and an emphasis on the applicable 
computational thinking skills required, followed by students creating their own 
Scratch based solutions [1]. The programs that the students developed were evaluated 
for their ability to decompose the problem at hand and the skill in efficient program 
development [1]. The study found that basic concepts like sequence were easy for 
students to pick up on, but that as program requirements became more sophisticated
 it was increasingly difficult for the participants to compose and debug their programs [1].\\

Applying these findings to our own sequence of instruction has informed us on the 
importance of properly conveying the progression of topics. It is essential that we 
not only deliver clear information about the mechanics of each element of our game, 
but also that we properly articulate and demonstrate the more complex topics, such 
as nested if statements or nested loops. The sequence of instructions and data structures 
being introduced needs to support a logical progression from simple to more complex 
topics, and it is necessary to ensure that players are familiar with concepts before a new 
one is introduced. For example, we wouldn’t want to introduce new instructions in 
succession, but rather require the player to solve several puzzles with each element to 
build familiarity and comfort before a new element is introduced.  Additionally, we 
recognize that proper conveyance of debugging practices and insightful feedback 
on this practice is an integral aspect of user success.\\

A second Scratch based research that was conducted involved Freshmen level college 
students, which is much more in line with our project's target audience. All of the 
students in the study were either Computer Engineering, Software Engineering, or 
Informational Systems Engineering majors, and the college requires all Engineering 
students to take their Computer Science I course in their second semester. The model 
for this study was a modification of the Computer Science I course at the university 
the papers' authors both taught at that added a Scratch project as part of the grading 
criteria for the course [2]. Aside from this addition, the course was identically structured 
to all other semesters the course was offered. When the performance of students in 
the experimental course was compared against the performance of students in the 
traditional course, it was found that students in the experimental version -- the one 
supplemented with the Scratch project -- performed significantly better than the 
others [2]. Additionally, the progress of these students was tracked over their four 
years of college curriculum to determine whether or not this augmented form of 
instruction in the core class might have lasting effects. Interestingly, it was found that 
while these students performed unquestionably better in a Senior Design project than 
their peers, the deviation of CGPA between the two groups was negligent [2]. The 
paper also notes that while the students enrolled in the experimental program consistently
outperformed their peers, the failure rates remained the same as the traditional version of 
the course at this institution, over 50\% [2]. \\

The paper makes note of many key pieces of information in regards to the difficulty of 
the subject, but most importantly among them that ``the programming concepts and 
language syntax may become barriers for learning programming and an inhibiting factor 
for motivation among students" [2]. This reinforces one of the main points our project 
aims to address -- that students first entering programming classes are overwhelmed by 
needing to learn syntax as well as computational thinking, as well as how to use them in 
conjunction with the concepts of the course. By acquainting players with computational 
thinking and algorithmic processes before they enter these introductory level courses, 
we hope to ease this perceived inhibition and allow students to approach their new 
topics and learning syntax with confidence. Additional hurdles that students encounter 
in learning programming include the large number of concepts that need to be mastered, 
the absence of instant feedback via interactive media, and a lack of strong problem-solving 
skills [2]. Our project aims to address all three of these issues by design. The concepts 
students encounter in these courses will already have been introduced to them through 
the course of completing our game, and problem-solving skills -- especially those related 
to solving problems using the concepts learned in these courses -- will be honed and 
tested as they progress through the levels. Through the animations of our character 
carrying out their coded solutions, our game also provides instant feedback on how 
well their solution actually works on the problem in question.\\

Another research team utilized a system they developed to create tiling patterns to teach 
basic programming concepts to students, such as sequence of execution, loops, and 
recognizing logic errors [3]. Tilings were selected because they allow creative 
exploration for the students while their construction is still rooted in a process that can 
be done computationally and followed with linear progression [3]. Similar to the simple 
pseudo-language that our game features, the researchers made a simple text-based 
language for students to use to produce tiling sequences and used it in an introductory 
programming course at a college, noting that using high level languages like C are often
overwhelming for new programming students [3]. Indeed, using a language like C or 
Java to produce the same pattern that students made with their simple language in their 
first lesson would take a student hours of studying syntax, learning programming 
concepts, and then applying problem solving to produce the correct pattern. Just as in 
the previous study, this research was conducted on college freshmen in fields that 
require Computer Science with little to no prior programming experience, which is our 
key demographic. Students who participated in the testing of this method of instruction 
were invited to fill out a voluntary survery about their perception of its efficacy. About 
53\% of students said that the use of the tiling program increased their knowledge in 
programming, as well as showing favorable agreement with statements indicating the 
system was engaging, fun, and increased their understanding of the programming 
concepts presented [3].\\

The method of delivery of concept for this study was of particular interest to us. By 
abstracting away from complex syntax and utilizing a simple textual language, the 
researchers were able to very effectively convey concepts, and students were 
comfortable using the commands provided to form their solutions to the problems 
they were presented with. The paper notes that these simple languages are so effective 
because they have a small command set and simple syntax, and are based on familiar 
verbage that clearly express their function [3]. This use of familiar language to teach 
new concepts helps users by concentrating on the function and concept of the 
commands instead of getting bogged down in technical terminology. Another interesting 
point that was made is that introductory courses are often focused on processing 
information that is not interesting to novice programmers, and therefore they are 
less motivated to complete the work or pursue fields centered around programming [3]. 
By abstracting the instruction of these concepts into another format that users find 
captivating, such as a game, we can increase the chances that students will be motivated 
to apply themselves to the offerings of Computer Science. Further, using a system that 
delivers immediate visual feedback is a much more rewarding form of response than 
waiting for a program to execute only to find the expected output is wrong, and trying 
to trace back through the length of the code to discover the errors. Indeed, giving 
immediate and meaningful feedback to a beginner in any subject is vital to their 
continued progress and success [3]. Our game will achieve this via the visual execution 
of the players solution being carried out by our character. \\

These first three research projects are all characterized by using some sort of visual 
coding format either as a supplement to, or as the tool for, delivering programming 
based instruction to beginners. Other research we found concentrated more specifically 
on the effectiveness of using games as a medium for teaching computational thinking 
or programming concepts to users. Documentation concentrating on this topic was of 
special interest to us, as it applies so directly to our goals for this project. There are 
already many studies based around the idea of using game-based instruction for teaching, 
and it has been firmly established that it is a successful medium for delivering instructional 
content. The real issue we are facing is whether or not it can be used effectively in regard 
to teaching computational thinking.\\

One such study we found aimed to teach computational thinking concepts using 
“unplugged” games to teach the elements, and then following the unplugged activities 
the students would apply what they had learned to correlated “plugged-in” programming 
exercises [4]. The unplugged version included tangible real world objects (e.g., a deck 
of cards) that students would physically interact with in order to demonstrate understanding 
of a particular concept, and the plugged-in version would present the participants with 
the same object computationally and ask them to trace through a solution based on the 
concept and rules they were already familiar with for that particular object. The reasoning 
for this abstract approach is that the underlying computational concepts can be learned 
in any medium, and that by removing the technological applications the emphasis is 
specifically on the processing of information using computational thinking instead of 
having the participants focus too much on the technology they are using [4]. It was 
found that for most of the activities, a majority of the students were able to accurately 
solve the tasks on the plugged-in assessments with approximately 90 percent 
correctness [4]. However, the activity that aimed to teach students about conditionals 
and nested conditionals had very disappointing results, with students only solving 6 
percent of the final assessment for that lesson correctly [4]. There was also a 
questionnaire element to this study designed to help the researchers measure the 
interest the students had in pursuing an IT-related job, which the students filled out 
both before the course and after it ended. Interestingly, the results actually indicated 
a slight decline in students interested in choosing a related job after completing the 
course, but contrastingly showed an increase in the desire to learn more about 
computer science, and also indicated that students enjoyed the course and felt they 
learned something valuable [4]. The shortcomings of this study with respect to 
teaching conditionals can likely be attributed to not spending enough time on the 
topic and the ending assessment being too complex [4].\\

This has greatly informed us on how we want to introduce this topic within our 
own project. First, we would like to introduce single conditionals in a tutorial level 
and then have the user solve a non-trivial puzzle using the concept, followed with 
another tutorial level showing them how to operate with nested conditionals and a 
subsequent puzzle implementing that technique. Layering this instruction instead of 
releasing it to them all at once should help users understand the basics of conditionals 
before allowing them to get bogged down in more complex applications. It should 
also be noted that the instructors for this study were trained in teaching for only 
two hours a week over the course of three months [4], whereas, cumulatively, the 
members of our team have years of experience in teaching these concepts to novices. 
Still, the results of the overall effectiveness of gamification of computational thinking 
concepts as a solid method for instruction is very promising, and with the right approach 
we know that our project can be successful.\\