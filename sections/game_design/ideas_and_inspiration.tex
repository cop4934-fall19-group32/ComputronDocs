The beginning of our project was characterized by a great deal of brainstorming. We took great strides
to avoid a herd mentality when discussing possible game mechanics, themes, and designs. We frequently
separated to come up with ideas as individuals before returning to blend those ideas together into a more
cohesive whole.

\subsubsection{Brandy King}\mbox{} \\
Many of my ideas for Computron came from observing players struggle with games like \textit{Human
Resource Machine}. I focused a lot on the shortcomings of those games; more specifically, I aimed to fill in
what they were lacking in terms of the accessibility that they provide to inexperienced programmers.
Additionally, I wanted the game to feel engaging and rewarding for players, something that is often
overlooked in the development of educationally focused video games. \\

\paragraph{Declaring Variables and Data Structures:}\mbox{} \\
When we were discussing the scope of the instruction set we wanted for our game, I put forward the idea
of including a ``declare" instruction that players would use to initialize a variable or data structure for use
in their solution. This would be tied dynamically to the instructions they are able to use, as some instructions
are only applicable to these items, like the Move and Copy commands. These commands have a blank field
that the user has to fill with an available structure, so if they didn't declare the item, they wouldn't be able to
link it to the command.\\

The hope was that this would reinforce the notion of instantiation of data structures for use in a program. By
making the player responsible for managing the data structures, it would emphasize how a programmer
is responsible for declaring and utilizing variables and data structures to handle data within an algorithm. In
discussing the mechanics of how this would work, it became clear that implementing the declaring functionality
as a command would be very difficult to do dynamically, so it was adapted to be its own section, separate from
the solution that the player builds. This way, the variables and data structures could still be handled dynamically,
both in their declaration and in their attachment to instructions in the solution.\\

\paragraph{Tutorial Levels:}\mbox{} \\
It became clear very early on that many of the current game offerings in this arena did a lackluster job of
providing a solid introduction to their game. Many of the games escalated in difficulty far too quickly for
players new to programming to follow along with. They could complete the first few introductory puzzles,
but were quickly lost when the game mechanics became more complex or increased in scope. It was evident
that having a very solid tutorial aspect to our game was vital to our success in conveying concepts.\\

I proposed that we intersperse tutorial levels between puzzles in the flow of the game. We already knew that
as players progressed through the game they would unlock access to new data structures and commands. As
soon as a new item was unlocked, a tutorial level would be the next puzzle in the game. This would be a free-play
level with unlimited input and no determined solution wherein the player could experiment with and explore
the functionality of their newly unlocked item without the pressure of immediately needing it to solve a puzzle.\\

In order to ``complete" each tutorial level, the player would be required to complete a short to-do list that
covered the basic concepts of their new command or data structure, after reading a brief description of the function
and mechanics of what that item does. For example, a Heap tutorial level to-do list would include:
\begin{itemize}
	\item Declare a Heap
	\item Put five inputs in the Heap
	\item Remove five inputs from the Heap
\end{itemize}
As each item on the to-do list is completed, it will be checked off automatically for the player. Once it is fully
completed, they can elect to exit the tutorial whenever they are ready and move forward to the next
puzzle, which will necessarily utilize the new element in its solution. \\

\paragraph{Limiting Certain Commands:}\mbox{} \\
By limiting the capabilities of certain commands, we can better communicate to players the functions of certain
elements in the game. As previously stated, the Move and Copy commands are only useful in conjunction with a
variable or data structure. These commands could be in the list of available instructions for a level, but they would be
dulled out and inaccessible to the user until a proper variable or data structure was declared.\\

Similarly, some commands will not be able to be used with certain data structures. For instance, the Add and Subtract
commands can be used on variables, but we should not allow players to arbitrarily use Add or Subtract on the
top element of a Heap, Stack, or Queue. The player would be required to remove that element from the structure,
manipulate the data, and then put the modified data into the structure. This reinforces the core concepts of how
these structures are used for storage, and will also encourage players to select the right type of structure depending
on how they may need to manipulate the data in that level.\\

\paragraph{Instruction ``Jumbotron":}\mbox{} \\
In \textit{Human Resource Machine}, as the character is acting out the instructions for the player, there is an indicator
in the panel containing the player's solution that points to which command is being executed at that time. While this
is very useful when trying to trace through a solution or debug a problem in the code, it is also a bit too subtle
and most users that I observed didn't notice it at all, even when they were stepping through their solution one
command at a time.\\

From this, I got the idea of introducing a ``Jumbotron" element in the User Interface of the puzzle that would
show up during execution and broadcast which instruction was being executed at that time. My hope was that the
text of the command the user had in their solution paired with the actions of the Actor on the screen would more
directly emphasize what action was caused by each instruction. This would, in turn, create an association between
the commands and the way they effect the flow of the puzzle, which was something that seemed to be lost to new users
who were inexperienced at programming.\\

\paragraph{Indentation Within Conditional Blocks:}\mbox{} \\
When conditional statements are presented in the games we playtested, there was no indication of which code
belonged inside of the conditional block or where that block ended. This is because the conditions had to be
controlled with jump statements. However, for users who are not accustomed to scoping and how code blocks
work, it is very unclear where exactly a jump statement should go to end a block of code, or even to use a jump
statement in the first place.\\

Using indentation within conditional blocks provides a much clearer picture to the user of exactly what code belongs
to which piece of the logic in their solution. This is seen consistently throughout real world programming and coding
syntax, where indentation and spacing are paramount to the readability of code. By adopting this convention
in our pseudo-language, we can not only set up players for the way real programming languages are laid out, but
also communicate to them more clearly the flow of their solution.\\

\paragraph{Points-Based Scoring of Solutions:}\mbox{} \\
Making an educational game that people enjoy playing is extremely challenging. It is very important that, in addition
to being instructive, our game should also be enjoyable. We can foster an early love for Computer Science by
creating a game that players want to return to. This can be achieved by implementing game mechanics that the
player can reference to see how well they are doing.\\

A point-based scoring system is a popular device implemented by many games. Scoring a solution out of three stars,
for example, clearly indicates to a player how well they solved the puzzle and whether or not there is room for
improvement. Simple mechanics like this can be a strong motivator for players to return to previously solved levels
and try a different approach in an attempt to get a better score. Encouraging this second look at a solution will
stimulate the idea of reevaluating old code and making an effort to improve upon it, especially once new concepts
have been learned.\\

\paragraph{Individual Puzzle Solutions Connecting to Solve Larger Puzzles:}\mbox{} \\
This idea is borrowed from the game \textit{SpaceChem}, which is a game that implements computational thinking
to solve puzzles. It falls more on the abstract side of the spectrum, but it has a game mechanic where the solution to
several puzzles is combined together as the input for another puzzle down the line.\\

In relation to our game, my idea was to have individual puzzles be part of a larger puzzle. The efficiency of each
of the solutions to three smaller puzzles will dictate how well each of those pieces works together, and ultimately
how well the puzzle that relies on those three pieces can be solved. This could be effectively implemented through
an overall game theme where each puzzle makes sense to be one component of a larger piece. This idea of nested
reliance will reinforce motivating players to revist puzzles that they have already solved to find more efficient solutions,
which can in turn lead to a better solution overall.\\

\subsubsection{John Billingham}\mbox{} \\
\paragraph{Abstracting Conditional Jumps:}\mbox{} \\
Conditional jumps run the possibility of bringing complex logic that may overwhelm
or confuse the player. While our instruction set is similar to assembly, we would like
to mimimize the complexity that is associated with assemply logic. One way that traditional
higher level programming languages achieve this is by introducing nested if/else conditional
statements.\\

These are essentially the same thing as a conditional jump. A statement is evaluated to
true or false and the flow of logic (the next instruction to be executed nad those after)
depends on this produced boolean value. Nested if/else blocks make this flow of logic
far more visually appealing. We must be careful though, by not allowing the player to create
additional complexities with confusing nested logic. Limiting the number of conditional
instructions that the player has access to can solve this problem. We can also just blatantly
limit the number of nests that we allow with conditional logic. It is important that we
do not create more complexities while trying to remove some here.\\

\paragraph{Jump Instructions as a Resource:}\mbox{} \\
Distributing jump instructions as a finite resource can enfore the idea of runtime
efficiency for those who play the game. The more jumps a player uses, especially those
that are not necessarily needed, may slow a player's solution down. A puzzle level may
be able to be solved in 10 different ways, but maybe there is a solution that is the fastest
and most efficient in terms of runtime and space.\\

We can push players towards the efficient solution by distributing jump instructions scarcely.
A reward system could also be introduced as a means to enforce these concepts. Players with
faster solutions (fewer steps/instructions executed) could gain some sort of point based
score that maybe allows them to unlock more levels down the road.\\

\paragraph{Data Structures}\mbox{} \\
Our initial inspirations and ideas for this game only contain one data structure that is
used on the game board: registers. Items can be placed in and taken out of these register and that
is it. Registers support two basic functionalities:
\begin{itemize}
  \item Item goes in register
  \item Item goes out of register
\end{itemize}

Computer Science relies on many other equally important data structures like stacks,
queues, and heaps. Rather than use just registers as components that players can use on
the game board to solve a puzzle, we can bring in other structures that allow them to
optimize their solution even further. This would really drive in some core Computer Science
material, something that most educational games of this genre fail to do.\\

These data structures were specifically mentioned because they also
all support two main functionalities like the registers above...\\

Stacks:
\begin{itemize}
  \item Push
  \item Pop
\end{itemize}

Queues:
\begin{itemize}
  \item Enqueue
  \item Dequeue
\end{itemize}

Heaps:
\begin{itemize}
  \item Insert
  \item Delete
\end{itemize}

Limiting data structures to this same input/output type of mechanisms allows our
actor to easily interact and communicate with these new game components.\\

Puzzle levels that were solved using a naive solution earlier on may be able to be
optimized at a later date after certain data structures have been introduced. We can
structure our puzzle level progression system to take this into account.\\

\paragraph{Atomic Move instructions:}\mbox{} \\
Having the actor pick up an item and place it down as two separate instructions
makes our instruction set feel too much like assembly code. Replacing this with one
atomic move instruction abstracts these two commands, making it simpler for the player
to understand it's use.\\

The previous functionality is preserved but the steps that a player has to take to achieve
such is reduced. This should help players solve levels faster by removing an unneeded
intermediate step of work.\\

The move instruction would contain two parameters: a source and a destination. When the
instruction is executed, the actor moves to the source, picks up the data located there, and moves
it to the destination specified by the instruction. This also makes our instruction set seem
more like orders for our actor to follow rather than a straight controlling of the actor's
every move.\\

\paragraph{Add/Subtract specificities:}\mbox{} \\
Add and subtract instructions would work very similarly to the move instruction
mentioned above. Two source register would be specified, either to be summed or differenced,
as well as a destination, where the sum or difference is placed.\\

The actor does the animation work of adding or subtracting data and moving it to the correct
location. This again removes additional logic that the player has to think through when
solving a puzzle.\\

\paragraph{Color-based indexing system}\mbox{} \\
The player accesses instructions through a color-based indexing system.
Colors represent specific data structures on the game board, while indices represent
specific locations within a colored data structure. "Green sub 3" would indicate the
3rd index within the green data structure.\\

This is meant to give the player more control over the locations that exist on the
game board. It is also meant to drive Computer Science concepts of indexing and accessing
different places in memory. We would conventionally use a variable and an index to access
certain data structures, but the variable is replaced by a uniquely colored visualization
of a data structure.\\

\paragraph{Return instruction}\mbox{} \\
Allow the user to choose a data structure to return as their output. The
contents of the data structure are checked agaisnt the expected output for the
puzzle level. The player chooses the data structure they wish to return by choosing
that data structure's color in the output game object.\\

\paragraph{Debugging levels}\mbox{} \\
The player can step back and forth through their solution, one instruction at a time,
and the actor should support these operations to show a visual debugging process. This
visual control can help players find problems within their solution, allowing them to
progressively reach the end of puzzle level.\\

\paragraph{Broken solution given initially}\mbox{} \\
Player must fix a broken solution that is given when the puzzle level starts.
Can be used in conjunction with tutorials to teach new concepts. This enforces the fuctionality
of certain data structures by having the player interact with a broken data structure being
introduced to them.\\

If a player has messed with and fixed a broken data structure prior to using it in one of
their futre solutions, our hope is that their ability to use this data structure and think in
terms of this data structure when building a solution will be increased.\\

\subsubsection{Nicolas LaCognata}\mbox{} \\
My biggest inspiration for this project was \textit{Human Resource Machine} by the Tomorrow Corporation.
\textit{Human Resource Machine} is a charming little puzzle game that tackles the problem we settled on solving,
the gamification of computational thinking. I love the game, and find it highly engaging. However, playtests
with non-programmers clearly demonstrated the games shortcomings when dealing with its target audience.

\paragraph{Basic Mechanics:}\mbox{} \\
When brainstorming the basic mechanics of our game, my mind continually strayed towards \textit{Human Resource Machine}.
Through playing the game, and watching others play it, it became clear that Tomorrow Corporation's decision to stick with
an assembly-like instruction set was an extremely effective mechanic.\\

The assembly like instructions were simple enough for non-programmers to understand, and easy to compose together to make more
advanced puzzles and solutions. Even at the risk of having our game appear as a rip-off, I thought it would be wise to adapt
these mechanics.

\paragraph{Data Structures:}\mbox{} \\
After surveying many games in the problem space, we failed to find an example of a game that tackles computational thinking
with the aid of Data Structures. Data Structures are such a fundamental part of being a programmer, that their omission in these
games seemed incorrect.

\paragraph{Card Game Mechanics:}\mbox{} \\
During our prototyping sessions, I came up with the idea of “Memory Cards”.
These memory cards would allow the player to declare register locations and data
structures before their program starts running. Making the mechanics of placing these
memory cards similar to a game like \textit{Hearthstone: Heroes of Warcraft} would be
a natural and compelling addition to our puzzle format. This “Memory Card” interface
would be separate from the normal instruction writing interface, which helps reinforce
the idea that they are separate parts of the puzzle. \\

Another benefit of this design is the ability to deliver new instructions and datastructures
to the player in a familiar (and exceptionally game-y) way, card packs. Card games deliver
goodies to players in little packages whose contents appear hidden. While discussing adapting
card game mechanics, we realized that having that little unboxing moment when introducing new
instructions to the player could be highly compelling. Other games in our problem space often
silently drop new instructions on the player as they progress. By making the new instructions
appear as a reward, we can ensure that the new mechanic being introduced gets the appropriate
attention from the player.

\subsubsection{Sean Simonian}
\begin{itemize}
  \item Static commands and restricted dynamic commands
  \begin{itemize}
    \item Certain commands in the language should be static, such as “Read
    Input”
    \item Certain commands in the language should have components that can be
    selected from drop down menus, such as “Jump if (blank) (blank) (blank)”
    \begin{itemize}
      \item This command would have 3 sections to specify, so the user could
      specify this command to be “Jump if x > 0”
    \end{itemize}
  \end{itemize}
  \item Break more complex challenges into multiple steps that get checked along
  the way.
  \begin{itemize}
    \item User would have instructions to complete one step of the complete
    level challenge at a time, run their solution, and if they pass then they
    move onto the next step, etc., until they work up to the solution.
    \item This would help players grasp more complex concepts that would be
    harder to teach as a single challenge that they have to break down on their
    own.
    \item Example: Merge Sort algorithm
    \begin{itemize}
      \item Step 1: split an array in half
      \item Step 2: split an array in half recursively
      \item Step 3: compare 2 of the sub arrays and swap them if necessary
      \item Step 4: recursively compare and swap sub arrays to build back up to
      the full sorted array
    \end{itemize}
  \end{itemize}
  \item For testing the educational efficacy of the game, we could create a set
  of short questions to be done on paper that require computational thinking.
  Before a test subject plays our game, we have them work through a few of the
  questions. Then after the test subject plays our game, we have them work
  through a few more questions from the set. Compare the results to see if they
  indicate whether our game helps users with computational thinking and problem
  solving.
  \item For testing the educational efficacy of the game, conducting official
  tests through the UCF psych department would be very beneficial if we are able
  to do so.
  \begin{itemize}
    \item Students taking courses such as Intro to Psychology are required to
    spend a certain number of hours as a test subject as part of their course
    grade. They use SONA to view available tests and sign up for a time slot,
    and the experiments that involve playing video games tend to fill up very
    quickly.
    \item Since Intro to Psychology is a general education course, many subjects
    are freshman, and the majority are not studying computer science or similar
    majors. This could provide an abundant set of candidates that match our
    target audience.
    \item We have to figure out who to contact if we want to set this up for
    next semester.
    \item The UCF psychology department may only allow these official tests to
    be set up and run by psych majors and/or psych graduate students doing
    research. If this is the case, we could look for a grad student conducting
    educational research who would be interested in “sponsoring” these official
    tests.
  \end{itemize}
  \item Incorporate basic cyber security and cryptography concepts into additional
  challenges/puzzles.
  \begin{itemize}
    \item This was a goal early on, but the current design for the game
    mechanics would make this difficult to add to the game.
  \end{itemize}
  \item Initial ideas for computer science concepts to teach. As we narrowed
  down the specifications for our game, these ideas were thrown out as they will
  not fit in the game at all
  \begin{itemize}
    \item Artificial intelligence, neural networks, machine learning
    \item Blockchain technology and its applications
  \end{itemize}
\end{itemize}
