The beginning of our project was characterized by a great deal of brainstorming. We took great strides to avoid a herd mentality when discussing possible game mechanics, themes, and designs. We frequently separated to come up with ideas as individuals before returning to blend those ideas together into a more cohesive whole.

\subsubsection{John Billingham}
\paragraph{Abstracting Conditional Jumps:} ~\\
Conditional jumps run the possibility of bringing complex logic that may overwhelm or confuse the player. While our instruction set is similar to assembly, we would like to minimize the complexity that is associated with assembly logic. One way that traditional higher level programming languages achieve this is by introducing nested if/else conditional statements.\\

These are essentially the same thing as a conditional jump. A statement is evaluated to true or false and the flow of logic (the next instruction to be executed and those after) depends on this produced boolean value. Nested if/else blocks make this flow of logic far more visually appealing. We must be careful though, by not allowing the player to create additional complexities with confusing nested logic. Limiting the number of conditional instructions that the player has access to can solve this problem. We can also just blatantly limit the number of nests that we allow with conditional logic. It is important that we do not create more complexities while trying to remove some here.\\

\paragraph{Jump Instructions as a Resource:} ~\\
Distributing jump instructions as a finite resource can enforce the idea of runtime efficiency for those who play the game. The more jumps a player uses, especially those that are not necessarily needed, the more it may slow down a player's solution. A puzzle level may be able to be solved in ten different ways, but maybe there is a solution that is the fastest and most efficient in terms of runtime and space.\\

We can push players towards the efficient solution by distributing jump instructions scarcely. A reward system could also be introduced as a means to enforce these concepts. Players with faster solutions (fewer steps/instructions executed) could gain some sort of point based score that maybe allows them to unlock more levels down the road.\\

\paragraph{Data Structures:} ~\\
Our initial inspirations and ideas for this game only contain one data structure that is used on the game board: registers. Items can be placed in and taken out of these registers and that is it. Registers support two basic functionalities:
\begin{itemize}
	\item Item goes into register
	\item Item goes out of register
\end{itemize}

Computer science relies on many other equally important data structures like stacks, queues, and heaps. Rather than use just registers as components that players can use on the game board to solve a puzzle, we can bring in other structures that allow them to optimize their solution even further. This would really drive in some core computer science material, something that most educational games of this genre fail to do.\\

These data structures were specifically mentioned because they also all support two main functionalities like the registers above.\\

Stacks:
\begin{itemize}
  \item Push
  \item Pop
\end{itemize}

Queues:
\begin{itemize}
  \item Enqueue
  \item Dequeue
\end{itemize}

Heaps:
\begin{itemize}
  \item Insert
  \item Delete
\end{itemize}

Limiting data structures to these same input/output type of mechanisms allows our Actor to easily interact and communicate with these new game components.\\

Puzzle levels that were solved using a naive solution earlier on may be able to be optimized at a later date after certain data structures have been introduced. We can structure our puzzle level progression system to take this into account.\\

\paragraph{Atomic Move instructions:} ~\\
Having the Actor pick up an item and place it down as two separate instructions makes our instruction set feel too much like assembly code. Replacing this with one atomic move instruction abstracts these two commands, making it simpler for the player to understand its use.\\

The previous functionality is preserved but the steps that a player has to take to achieve it is reduced. This should help players solve levels faster by removing an unneeded intermediate step of work.\\

The move instruction would contain two parameters: a source and a destination. When the instruction is executed, the Actor moves to the source, picks up the data located there, and moves it to the destination specified by the instruction. This also makes our instruction set seem more like orders for our Actor to follow rather than a straight controlling of the Actor's every move.\\

\paragraph{Add/Subtract specificities:} ~\\
Add and subtract instructions would work very similarly to the move instruction mentioned above. Two source registers would be specified, either to be summed or differenced, as well as a destination, where the sum or difference is placed.\\

The Actor does the animation work of adding or subtracting data and moving it to the correct location. This again removes additional logic that the player has to think through when solving a puzzle.\\

\paragraph{Color-based indexing system:} ~\\
The player accesses instructions through a color-based indexing system. Colors represent specific data structures on the game board, while indices represent specific locations within a colored data structure. ``Green sub 3" would indicate the third index within the green data structure.\\

This is meant to give the player more control over the locations that exist on the game board. It is also meant to drive computer science concepts of indexing and accessing different places in memory. We would conventionally use a variable and an index to access certain data structures, but the variable is replaced by a uniquely colored visualization of a data structure.\\

\paragraph{Return instruction:} ~\\
Allow the user to choose a data structure to return as their output. The contents of the data structure are checked against the expected output for the puzzle level. The player chooses the data structure they wish to return by choosing that data structure's color in the output game object.\\

\paragraph{Debugging levels:} ~\\
The player can step back and forth through their solution, one instruction at a time, and the Actor should support these operations to show a visual debugging process. This visual control can help players find problems within their solution, allowing them to progressively reach the end of the puzzle level.\\

\paragraph{Broken solution given initially:} ~\\
A proposed puzzle type where the player must fix a broken solution that is given when the level starts. This can be used in conjunction with tutorials to teach new concepts. This enforces the functionality of certain data structures by having the player interact with a broken data structure being introduced to them.\\

If a player has messed with and fixed a broken data structure prior to using it in one of their future solutions, our hope is that their ability to use this data structure and think in terms of this data structure when building a solution will be increased.\\

\subsubsection{Brandy King}
Many of my ideas for \textit{Computron} came from observing players struggle with games like \textit{Human Resource Machine} and \textit{7 Billion Humans}. I focused a lot on the shortcomings of those games; more specifically, I aimed to fill in what they were lacking in terms of the accessibility that they provide  to inexperienced programmers. Additionally, I wanted the game to feel engaging and rewarding for players, something that is often overlooked in the development of educationally focused video games. \\

\paragraph{Declaring Variables and Data Structures:} ~\\
When we were discussing the scope of the instruction set we wanted for our game, I put forward the idea of including a ``declare" instruction that players would use to initialize a variable or data structure for use in their solution. This would be tied dynamically to the instructions they are able to use, as some instructions are only applicable to these items, like the Move and Copy commands. These commands have a blank field that the user has to fill with an available structure, so if they didn't declare the item, they wouldn't be able to link it to the command.\\

The hope was that this would reinforce the notion of instantiation of data structures for use in a program. By making the player responsible for managing the data structures, it would emphasize how a programmer is responsible for declaring and utilizing variables and data structures to handle data within an algorithm. In discussing the mechanics of how this would work, it became clear that implementing the declaring functionality as a command would be very difficult to do dynamically, so it was adapted to be its own section, separate from the solution that the player builds. This way, the variables and data structures could still be handled dynamically -- both in their declaration and in their attachment to instructions in the solution.\\

\paragraph{Tutorial Levels:} ~\\
It became clear very early on that many of the current game offerings in this arena did a lackluster job of providing a solid introduction to their game. Many of the games escalated in difficulty far too quickly for players new to programming to follow along with. They could complete the first few introductory puzzles, but were quickly lost when the game mechanics became more complex or increased in scope. It was evident that having a very solid tutorial aspect to our game was vital to our success in conveying concepts.\\

I proposed that we intersperse tutorial levels between puzzles in the flow of the game. We already knew that as players progressed through the game they would unlock access to new data structures and commands. As soon as a new item was unlocked, a tutorial level would be the next puzzle in the game. This would be a free-play level with unlimited input and no determined solution wherein the player could experiment with and explore the functionality of their newly unlocked item without the pressure of immediately needing it to solve a puzzle.\\

In order to ``complete" each tutorial level, the player would be required to complete a short to-do list that covered the basic concepts of their new command or data structure after reading a brief description of the function and mechanics of what that item does. For example, a Heap tutorial level to-do list would include:
\begin{itemize}
	\item Declare a Heap
	\item Put five inputs in the Heap
	\item Remove five inputs from the Heap
\end{itemize}
As each item on the to-do list is completed, it will be checked off automatically for the player. Once it is fully completed, they can elect to exit the tutorial whenever they are ready and move forward to the next puzzle, which will necessarily utilize the new element in its solution. \\

\paragraph{Limiting Certain Commands:} ~\\
By limiting the capabilities of certain commands, we can better communicate to players the functions of certain elements in the game. As previously stated, the Move and Copy commands are only useful in conjunction with a variable or data structure. These commands could be in the list of available instructions for a level, but they would be dulled out and inaccessible to the user until a proper variable or data structure was declared.\\

Similarly, some commands will not be able to be used with certain data structures. For instance, the Add and Subtract commands can be used on variables, but we should not allow players to arbitrarily use Add or Subtract on the top element of a Heap, Stack, or Queue. The player would be required to remove that element from the structure, manipulate the data, and then put the modified data into the structure. This reinforces the core concepts of how these structures are used for storage, and will also encourage players to select the right type of structure depending on how they may need to manipulate the data in that level.\\

\paragraph{Instruction ``Jumbotron":} ~\\
In \textit{Human Resource Machine}, as the character is acting out the instructions for the player, there is an indicator in the panel containing the player's solution that points to which command is being executed at that time. While this is very useful when trying to trace through a solution or debug a problem in the code, it is also a bit too subtle and most users that I observed didn't notice it at all, even when they were stepping through their solution one command at a time.\\

From this, I got the idea of introducing a ``Jumbotron" element in the User Interface of the puzzle that would show up during execution and broadcast which instruction was being executed at that time. My hope was that the text of the command the user had in their solution paired with the actions of the Actor on the screen would more directly emphasize what action was caused by each instruction. This would, in turn, create an association between the commands and the way they effect the flow of the puzzle, which was something that seemed to be lost to new users who were inexperienced at programming.\\

\paragraph{Indentation Within Conditional Blocks:} ~\\
When conditional statements are presented in the games we playtested, there was no indication of which code belonged inside of the conditional block or where that block ended. This is because the conditions had to be controlled with jump statements. However, for users who are not accustomed to scoping and how code blocks work, it is very unclear where exactly a jump statement should go to end a block of code, or even to use a jump statement in the first place.\\

Using indentation within conditional blocks provides a much clearer picture to the user of exactly what code belongs to which piece of the logic in their solution. This is seen consistently throughout real world programming and coding syntax, where indentation and spacing are paramount to the readability of code. By adopting this convention in our pseudo-language, we can not only set up players for the way real programming languages are laid out, but also communicate to them more clearly the flow of their solution.\\

\paragraph{Points-Based Scoring of Solutions:} ~\\
Making an educational game that people enjoy playing is extremely challenging. It is very important that, in addition to being instructive, our game should also be enjoyable. We can foster an early love for computer science by creating a game that players want to return to. This can be achieved by implementing game mechanics that the player can reference to see how well they are doing, and that invite the player to continue practicing their solutions.\\

A point-based scoring system is a popular device implemented by many games. Scoring a solution out of three stars, for example, clearly indicates to a player how well they solved the puzzle and whether or not there is room for improvement. Simple mechanics like this can be a strong motivator for players to return to previously solved levels and try a different approach in an attempt to get a better score. Encouraging this second look at a solution will stimulate the idea of reevaluating old code and making an effort to improve upon it, especially once new concepts have been learned.\\

\paragraph{Individual Puzzle Solutions Connecting to Solve Larger Puzzles:} ~\\
This idea is borrowed from the game \textit{SpaceChem}, which is a game that implements computational thinking to solve puzzles. It falls more on the abstract side of the spectrum, but it has a game mechanic where the solution to several puzzles is combined together as the input for another puzzle down the line.\\

In relation to our game, my idea was to have individual puzzles be part of a larger puzzle. The efficiency of each of the solutions to three smaller puzzles will dictate how well each of those pieces works together, and ultimately how well the puzzle that relies on those three pieces can be solved. This could be effectively implemented through an overall game theme where each puzzle makes sense to be one component of a larger piece. This idea of nested reliance will reinforce motivating players to revisit puzzles that they have already solved to find more efficient solutions, which can in turn lead to a better solution overall.\\

\subsubsection{Nicolas LaCognata}
My biggest inspiration for this project was \textit{Human Resource Machine} by the Tomorrow Corporation. \textit{Human Resource Machine} is a charming little puzzle game that tackles the problem we settled on solving, the gamification of computational thinking. I love the game and find it highly engaging. However, playtests with non-programmers clearly demonstrated the games' shortcomings when dealing with its target audience.

\paragraph{Basic Mechanics:} ~\\
When brainstorming the basic mechanics of our game, my mind continually strayed towards \textit{Human Resource Machine}. Through playing the game, and watching others play it, it became clear that Tomorrow Corporation's decision to stick with an assembly-like instruction set was an extremely effective mechanic.\\

The assembly like instructions were simple enough for non-programmers to understand, and easy to compose together to make more advanced puzzles and solutions. Even at the risk of having our game appear as a rip-off, I thought it would be wise to adapt these mechanics.\\

\paragraph{Data Structures:} ~\\
After surveying many games in the problem space, we failed to find an example of a game that tackles computational thinking with the aid of Data Structures. Data Structures are such a fundamental part of being a programmer, that their omission in these games seemed incorrect.\\

\paragraph{Card Game Mechanics:} ~\\
During our prototyping sessions, I came up with the idea of “Memory Cards”. These memory cards would allow the player to declare register locations and data structures before their program starts running. Making the mechanics of placing these memory cards similar to a game like \textit{Hearthstone: Heroes of Warcraft} would be a natural and compelling addition to our puzzle format. This “Memory Card” interface would be separate from the normal instruction writing interface, which helps reinforce the idea that they are separate parts of the puzzle. \\

Another benefit of this design is the ability to deliver new instructions and data structures to the player in a familiar (and exceptionally game like) way, card packs. Card games deliver goodies to players in little packages whose contents appear hidden. While discussing adapting card game mechanics, we realized that having that little unboxing moment when introducing new instructions to the player could be highly compelling. Other games in our problem space often silently drop new instructions on the player as they progress. By making the new instructions appear as a reward, we can ensure that the new mechanic being introduced gets the appropriate attention from the player. \\

\subsubsection{Sean Simonian}
Much of my inspiration for creating this game comes from my experiences of being in the positions of struggling greatly with introductory computer science concepts, to later tutoring beginner computer science students. Considering common issues that beginners struggle with, as well as feedback and observations from non-technical students playtesting our game prototypes, serves as the strongest indicator of how we need to design our product in order to best serve our target audience. Like the other team members, I drew inspiration from a few games that share similar goals or mechanics as what we envisioned for our game, such as \textit{Human Resource Machine}. As someone with less fondness and experience with the video game industry, I also spent some time focusing on the broader idea of creating a tool to benefit students learning computer science concepts, and I explored ways to pivot the basis for how we could create such a tool. Having real-world experience and passion for both software development and cyber security has greatly influenced my goals for our final product, and I hope to tie some of these concepts together in an encouraging manner for our final product.\\

\paragraph{Static vs Dynamic Commands:} ~\\
Certain commands in the language should be static, such as “Read Input”, while others should have components that can be selected from drop down menus, such as “Jump if (blank) (blank) (blank)”. This command would have three sections to specify, so the user could specify this command to be “Jump if x = 0”.\\

\paragraph{Puzzle Checkpoints:} ~\\
Break more complex challenges into multiple steps that get checked along the way. Users would be instructed to complete one step of the complete level at a time, run their solution, and if they pass then they move onto the next step, until they work up to the full solution. This would help players grasp more complex concepts that would be harder to teach as a single challenge that they would need to break down on their own.\\

Example: Merge Sort
\begin{enumerate}
                \item Split an array in half recursively
                \item Compare two of the sub arrays and swap them if necessary
                \item Recursively compare and swap sub arrays to build back up to the full sorted array
            \end{enumerate}

\paragraph{Testing the Game's Educational Efficacy:} ~\\
We could create a set of short questions to be done on paper that require computational thinking. Before a test subject plays our game, have them work through a few of the questions. After the test subject plays our game, have them work through a few more questions from the set. Compare the results to see if they indicate whether our game helps users with computational thinking and problem solving.\\

Conducting official tests through the UCF Psychology department would be very beneficial if we are able to do so. Students taking courses such as Intro to Psychology are required to spend a certain number of hours as a test subject as part of their course grade. They use SONA to view available tests and sign up for a time slot, and the experiments that involve playing video games tend to fill up very quickly. Since Intro to Psychology is a general education course, many subjects are freshmen and the majority are not studying computer science or similar majors. This could provide an abundant set of candidates that match our target audience. The UCF Psychology department may only allow these official tests to be set up and run by Psychology majors and/or Psychology graduate students doing research. If this is the case, we could look for a graduate student conducting educational research who would be interested in sponsoring these official tests.\\